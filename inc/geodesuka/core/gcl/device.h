#pragma once
#ifndef GEODESUKA_CORE_GCL_DEVICE_H
#define GEODESUKA_CORE_GCL_DEVICE_H

#include <vector>

#include "config.h"
namespace geodesuka::core::gcl {

	class device {
	public:

		friend class engine;
		friend class context;

		// qfeo
		// Queue Family Execution Operation
		enum qfeo {
			TRANSFER				= 0x00000001,
			COMPUTE					= 0x00000002,
			GRAPHICS				= 0x00000004,
			GRAPHICS_AND_COMPUTE	= GRAPHICS | COMPUTE,
			PRESENT					= 0x00000008
		};

		enum memory {
			DEVICE_LOCAL			= 0x00000001,
			HOST_VISIBLE			= 0x00000002,
			HOST_COHERENT			= 0x00000004,
			HOST_CACHED				= 0x00000008,
			LAZILY_ALLOCATED		= 0x00000010,
			PROTECTED				= 0x00000020
		};
		
		struct queue_family_capability {
			// Supported Operations
			VkQueueFlags Flags;
			bool isTransferSupported;
			bool isComputeSupported;
			bool isGraphicsSupported;
			bool isPresentSupported;
			unsigned int Support;
		};

		// Managed by engine, should be generated by engine.
		device(engine* aEngine, vk_physical_device aPhysicalDevice);
		~device();

		// User can provide a list of extensions to this method to check if they are all
		// supported. Will return true if provided list of extensions is supported. Will
		// return false if at least one extension is not supported.
		bool is_extension_list_supported(uint32_t aExtensionCount, const char** aExtensionList) const;

		// ----- Query ----- //

		vk_physical_device_properties get_properties() const;
		vk_physical_device_features get_features() const;
		vk_physical_device_memory_properties get_memory_properties() const;
		const vk_extension_properties* get_extensions(uint32_t* aExtensionCount) const;
		int get_memory_type_index(vk_memory_requirements aMemoryRequirements, int aMemoryType) const;
		int get_memory_type(int aMemoryTypeIndex);

		const vk_queue_family_properties* get_queue_family_properties(uint32_t* aQueueFamilyCount) const;
		const queue_family_capability* get_capability(uint32_t* aQueueFamilyCount) const;

		vk_surface_capabilities_khr get_surface_capabilities(vk_surface_khr aSurface);
		std::vector<vk_surface_format_khr> get_surface_format(vk_surface_khr aSurface);
		std::vector<vk_present_mode_khr> get_surface_present_mode(vk_surface_khr aSurface);

		//vk_image_format_properties image_format_properties(vk_format format, vk_image_type type, vk_image_tiling tiling, vk_image_usage_flags usage, vk_image_create_flags flags);

		// Checks if device has a queue that supports desired operations.
		bool available(unsigned int aQFS) const;

		// Input desired operations, and returns family index of a Queue that supports the desired operations
		// with minimum extraneous options. If the desired operations are not supported by the device, the 
		// function will return -1.
		int qfi(unsigned int aQFS) const;

		// ----- Handles ----- //

		vk_instance inst();
		vk_physical_device handle();

	private:

		//std::vector<object::system_display*> ChildDisplay;

		vk_instance ParentInstance;
		vk_physical_device Handle;

		uint32_t QueueFamilyCount;
		vk_queue_family_properties* QueueFamilyProperty;
		queue_family_capability* QueueFamilyCapability;
		uint32_t* QueueFamilySupportCount;

		// Properties, Features, and Extensions Available.
		uint32_t ExtensionCount;
		vk_extension_properties* Extension;
		vk_physical_device_properties Properties{};
		vk_physical_device_features Features{};
		vk_physical_device_memory_properties MemoryProperties{};

	};

}

#endif // !GEODESUKA_CORE_GCL_DEVICE_H
