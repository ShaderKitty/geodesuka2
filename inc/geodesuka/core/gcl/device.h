#pragma once
#ifndef GEODESUKA_CORE_GCL_DEVICE_H
#define GEODESUKA_CORE_GCL_DEVICE_H

#include <vector>

#include "config.h"
namespace geodesuka::core::gcl {

	class device {
	public:

		friend class engine;
		friend class context;

		// qfeo
		// Queue Family Execution Operation
		enum qfeo {
			TRANSFER				= 0x00000001,
			COMPUTE					= 0x00000002,
			GRAPHICS				= 0x00000004,
			GRAPHICS_AND_COMPUTE	= GRAPHICS | COMPUTE,
			PRESENT					= 0x00000008
		};

		enum memory {
			DEVICE_LOCAL			= 0x00000001,
			HOST_VISIBLE			= 0x00000002,
			HOST_COHERENT			= 0x00000004,
			HOST_CACHED				= 0x00000008,
			LAZILY_ALLOCATED		= 0x00000010,
			PROTECTED				= 0x00000020
		};
		
		struct queue_family_capability {
			// Supported Operations
			VkQueueFlags Flags;
			bool isTransferSupported;
			bool isComputeSupported;
			bool isGraphicsSupported;
			bool isPresentSupported;
			unsigned int Support;
		};

		// Managed by engine, should be generated by engine.
		device(engine* aEngine, VkPhysicalDevice aPhysicalDevice);
		~device();

		// User can provide a list of extensions to this method to check if they are all
		// supported. Will return true if provided list of extensions is supported. Will
		// return false if at least one extension is not supported.
		bool is_extension_list_supported(uint32_t aExtensionCount, const char** aExtensionList) const;

		// ----- Query ----- //

		VkPhysicalDeviceProperties get_properties() const;
		VkPhysicalDeviceFeatures get_features() const;
		VkPhysicalDeviceMemoryProperties get_memory_properties() const;
		const VkExtensionProperties* get_extensions(uint32_t* aExtensionCount) const;
		int get_memory_type_index(VkMemoryRequirements aMemoryRequirements, int aMemoryType) const;
		int get_memory_type(int aMemoryTypeIndex);

		const VkQueueFamilyProperties* get_queue_family_properties(uint32_t* aQueueFamilyCount) const;
		const queue_family_capability* get_capability(uint32_t* aQueueFamilyCount) const;

		VkSurfaceCapabilitiesKHR get_surface_capabilities(VkSurfaceKHR aSurface);
		std::vector<VkSurfaceFormatKHR> get_surface_format(VkSurfaceKHR aSurface);
		std::vector<VkPresentModeKHR> get_surface_present_mode(VkSurfaceKHR aSurface);

		//VkImageFormatProperties image_format_properties(VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags);

		// Checks if device has a queue that supports desired operations.
		bool available(unsigned int aQFS) const;

		// Input desired operations, and returns family index of a Queue that supports the desired operations
		// with minimum extraneous options. If the desired operations are not supported by the device, the 
		// function will return -1.
		int qfi(unsigned int aQFS) const;

		// ----- Handles ----- //

		VkInstance inst();
		VkPhysicalDevice handle();

	private:

		//std::vector<object::system_display*> ChildDisplay;

		VkInstance ParentInstance;
		VkPhysicalDevice Handle;

		uint32_t QueueFamilyCount;
		VkQueueFamilyProperties* QueueFamilyProperty;
		queue_family_capability* QueueFamilyCapability;
		uint32_t* QueueFamilySupportCount;

		// Properties, Features, and Extensions Available.
		uint32_t ExtensionCount;
		VkExtensionProperties* Extension;
		VkPhysicalDeviceProperties Properties{};
		VkPhysicalDeviceFeatures Features{};
		VkPhysicalDeviceMemoryProperties MemoryProperties{};

	};

}

#endif // !GEODESUKA_CORE_GCL_DEVICE_H
